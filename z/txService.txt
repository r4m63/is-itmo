TransactionSynchronizationRegistry - JTA-сервис, который даёт доступ к текущей транзакции на текущем потоке и позволяет:
	1.	регистрировать колбэки на жизненный цикл транзакции (Synchronization)
	2.	хранить данные привязанные к транзакции (putResource/getResource)
	3.	узнавать статус транзакции (getTransactionStatus())
Важно:
	•	TSR работает только если на потоке реально есть активная JTA-транзакция.
	•	Внутри @Transactional контейнер открывает транзакцию → и TSR “видит” её.


txRegistry.registerInterposedSynchronization() - подписаться на события этой транзакции
Именно на этом месте контейнер запоминает объект Synchronization и потом вызовет его методы при завершении транзакции
•	interposed synchronization вызывается чуть “ближе” к самому коммиту ресурсов (по сути, в правильном месте, чтобы логика успела повлиять на исход коммита).
•	Для задачи это нужно, чтобы beforeCompletion() выполнялся перед реальным коммитом БД, и если там упасть — коммит БД не произойдёт.

new Synchronization() - интерфейс JTA с двумя колбэками:
•	beforeCompletion()
•	afterCompletion(int status)
Это хуки, которые Transaction Manager вызывает при завершении транзакции.






========================================================================================================================
AtomicInteger

AtomicInteger здесь используется как изменяемый контейнер для счётчика, потому что переменная должна быть effectively
final, чтобы её можно было использовать внутри анонимного Synchronization; это не про многопоточность, а про возможность
менять значение и потом прочитать его в afterCompletion. Альтернативы — final int[] {0} или свой holder-класс.

В этом методе я считаю importedCount и использую его в двух местах:
	1.	в цикле импорта (увеличиваю после каждого vehicleDao.save)
	2.	в колбэке транзакции afterCompletion() — чтобы записать в лог, сколько успело обработаться к моменту завершения транзакции

Проблема Java: Synchronization — это анонимный класс, и он “захватывает” (captures) локальные переменные метода.
А по правилам Java захваченные локальные переменные должны быть final или effectively final.

Поэтому нужен “контейнер”, который:
	•	сам может быть final (ссылка не меняется),
	•	но внутри хранит изменяемое значение.
AtomicInteger идеально подходит как mutable holder

То есть AtomicInteger здесь используется не для thread-safety конкуренции, а как удобная “коробка с числом”, которую можно менять и читать из колбэка.











