



2_ConcurrentUpdateDelete

UPDATE SAME
    Оба делают select ... where x = ? and y = ? → ничего не находят.
    Оба пытаются INSERT (x, y) → один успевает первым, у второго 23505 duplicate key.

    Вторая транзакция всё ещё пытается сделать INSERT в coordinates с теми же (x, y).
    В БД стоит UNIQUE (x, y) → PostgreSQL кидает ошибку 23505.
    Hibernate оборачивает её в ConstraintViolationException.
    Ошибка поднимается до REST и превращается в 500.

    Почему try/catch не сработал (даже если ты его добавил правильно):
    PostgreSQL:
        при любой SQL-ошибке вся транзакция становится “aborted”.
        Пока не сделан ROLLBACK, любые следующие запросы внутри транзакции тоже будут падать.
    JTA/Hibernate:
        как только SQLException «вылез» до Hibernate, транзакция помечается как rollback-only, и JTA в конце скажет RollbackException.

    РЕШЕНИЕ:
        INSERT ... ON CONFLICT (x, y) DO NOTHING
        Это как раз идеально под твою задачу:
        если координат нет → вставятся,
        если уже есть → запрос просто не сделает ничего, без ошибки,
        потом мы делаем обычный SELECT и получаем одну и ту же строку во всех потоках.


    + LOST UPDATE
    При конкурентном обновлении одной и той же записи vehicle оба запроса завершаются успешно (HTTP 204), однако
    финальное состояние объекта зависит от порядка коммита транзакций. Это приводит к аномалии типа lost update:
    изменения одного пользователя могут быть бесшумно перезаписаны другим



DELETE SAME
    T1: existsById(10) - в БД есть
    T2: existsById(10) - в БД есть
    T1: делает deleteById(10) - удаляет строку - коммитится успешно - получает 204 No Content
    T2: (в начале видел, что запись есть (existsById)), но когда доходит до коммита, Hibernate/JTA внезапно обнаруживают: строки с id=10 уже нет (её удалил T1)
    Т2: OptimisticLockException, Из-за OptimisticLockException JTA-менеджер помечает транзакцию T2 как rollback-only и при коммите падает с: RollbackException

    я сделал:
        @Version
        @Column(name = "version", nullable = false)
        private Integer version;
    и так же catch (OptimisticLockException)


3_UniqueNameConcurrentCreate

insert 2 entities with same business-unique name
    этим тестом доказывается, что чисто программная проверка existsByName + отсутствие UNIQUE в БД не гарантирует уникальность под конкуренцией.

    Поток 1 и поток 2 одновременно заходят в createNewVehicle.
    Оба вызывают existsByName("JMeter-Unique-Test") в рамках своих транзакций.
    В БД пока нет такой записи → оба получают false.
    Оба делают save() → в таблице оказываются две строки с одинаковым name.
    Оба получают 201 Created.

    serializable isolation или pessimistic locking

    - LockModeType.PESSIMISTIC_WRITE применяется только для существующих записей (при чтении и обновлении), чтобы обеспечить атомарность и избежать конфликтов между транзакциями.


update 2 entities to same business-unique name
