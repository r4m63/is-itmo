XA — спецификация интерфейсов для участия ресурса в распределённой транзакции под управлением Transaction Manager (JTA)

Если ресурс “XA-совместимый”, значит у него есть драйвер/адаптер, который умеет:
	•	присоединиться к глобальной транзакции (с XID),
	•	выполнить prepare (“я готов коммититься”),
	•	затем выполнить commit или rollback.
ресурс может участвовать в протоколе prepare/commit/rollback под управлением менеджера транзакций.



XA-2PC ПРОТОКОЛ
XA-2PC — это двухфазный коммит, который выполняет Transaction Manager по XA-протоколу:
	1.	prepare у всех участников
	2.	commit у всех, если все “готовы”



СПОСОБЫ РЕАЛИЗАЦИИ:



Настоящий 2PC через JTA/XA (классика)
    Как: оба (или больше) ресурса XA-совместимые, Transaction Manager делает prepare/commit.
    Примеры: DB(XA) + JMS(XA), DB(XA) + DB(XA).
    Плюсы: сильная атомарность.
    Минусы: сложнее админить, дороже, и не работает с MinIO напрямую.
    ------------------------------------------------------------
    Это настоящая распределённая транзакция, где Transaction Manager (JTA) управляет несколькими XA-ресурсами через протокол XA.
    Ресурс XA = умеет prepare/commit/rollback на уровне драйвера (реализует XAResource).
    Примеры XA-ресурсов:
    	•	XA DB (через XADataSource)
    	•	XA JMS (через XAConnectionFactory)
    	•	иногда XA для других систем
    Как работает по шагам:
    Предположим, у нас 2 XA-ресурса: DB и JMS.
    Фаза 1 — prepare
    	1.	Приложение работает в @Transactional → выполняет SQL в DB и операции в JMS.
    	2.	На commit Transaction Manager:
    	•	говорит DB: prepare(XID)
    	•	говорит JMS: prepare(XID)
    	3.	Каждый отвечает: OK (готов) или FAIL (не готов).
    Фаза 2 — commit/rollback
    	•	Если все OK → TM делает:
    	•	commit(XID) на DB
    	•	commit(XID) на JMS
    	•	Если кто-то FAIL → TM делает:
    	•	rollback(XID) на всех
    Что гарантирует:
    ✅ Атомарность между ресурсами: либо всё закоммитилось, либо всё откатилось (в рамках модели XA).
    ✅ Переживает многие виды сбоев (TM ведёт журнал, может “докоммитить” после рестарта).
    Минусы:
    	•	Нужны XA-драйверы/ресурсы.
    	•	Сложнее настройка/администрирование.
    	•	Медленнее (prepare — это дополнительные сетевые раунды, логи, блокировки).
    Важно: MinIO/S3 не XA → сюда не подходит.



2PC-оптимизация “Last Resource Commit / Last Participant” (LRCO)
    Как: один ресурс XA, второй НЕ-XA, но разрешают “последним коммитить” не-XA ресурс.
    Плюсы: иногда удобно.
    Минусы: не 100% надёжно при креше между шагами; зависит от контейнера/ТМ; на защите лучше не упирать на это.
    ------------------------------------------------------------
    Компромисс, когда:
    	•	есть несколько XA-ресурсов (или один XA),
    	•	и один не-XA ресурс, который TM разрешает коммитить последним как “Last Resource”.
    Идея: “раз уж один ресурс не умеет prepare, давайте хотя бы сделаем commit не-XA в правильный момент”.
    Это иногда называют:
    	•	Last Resource Commit Optimization
    	•	Last Participant Support
    Как работает по шагам:
    Предположим:
    	•	DB = XA
    	•	“второй ресурс” = не-XA (например обычный JDBC без XA, или что-то ещё, где TM имеет адаптер)
    Фаза 1 — prepare (только для XA-ресурсов)
    	1.	На commit TM делает prepare(XID) только XA-участникам (DB).
    	2.	Если DB сказал OK → продолжаем.
    “Фаза 2” — commit в особом порядке
    	3.	TM делает commit для не-XA (“last resource”) — как правило перед финальным commit XA или в зависимости от реализации.
    	4.	Затем TM делает commit(XID) XA-ресурсам.
    Чем это отличается от настоящего 2PC
    	•	У “last resource” нет prepare, значит он может “успешно коммитнуть”, а потом что-то случится и XA часть не закоммитится → появляется риск рассинхронизации.
    Гарантии и риски:
    ✅ Лучше, чем просто “вручную два коммита”
    ❌ Но не даёт такой же надёжности, как XA-2PC.
    Где ломается:
    	•	если после коммита не-XA ресурса падает процесс/TM, а XA commit не завершился → можно получить “внешний эффект есть, а БД нет” (или наоборот, зависит от порядка).
    Где применяется:
    Иногда контейнеры/ТМ используют это, чтобы поддержать “одна DB без XA + JMS XA” или наоборот. Но это очень зависит от платформы, и не всегда включено/рекомендовано.
    Важно: для MinIO это практически не применяют напрямую (это не ресурс типа JDBC/JMS, это HTTP).



Best-effort 2PC на бизнес-логике (через JTA Synchronization)
    Как: DB — основная транзакция. В beforeCompletion() делаешь действие во внешнем ресурсе, если падает — бросаешь исключение → DB rollback. В afterCompletion() делаешь cleanup.
    Плюсы: соответствует вашему заданию (“собственная реализация 2PC”).
    Минусы: внешний ресурс не делает prepare, поэтому возможны редкие “несогласованности” при крешах сети/процесса.
    ------------------------------------------------------------
    Что это
    Это не XA и не “настоящий 2PC на уровне Transaction Manager”.
    Это подход, когда ты:
    	•	делаешь “главную” транзакцию в DB (JTA),
    	•	а внешний ресурс (MinIO) подключаешь “хуком” к lifecycle транзакции:
    	•	beforeCompletion() — попытка сделать внешний commit
    	•	afterCompletion() — cleanup/компенсация в зависимости от результата
    Это называют best-effort, потому что внешний ресурс не предоставляет prepare/rollback протокол.
    Как работает по шагам (твоя схема “DB → MinIO на коммите”)
    Во время транзакции
    	1.	В @Transactional вставляешь vehicles в DB.
    	2.	Регистрируешь Synchronization.
    Перед коммитом DB (beforeCompletion)
    	3.	Контейнер готовится коммитить DB и вызывает beforeCompletion().
    	4.	В beforeCompletion() ты делаешь:
    	•	minio.putObject(finalKey, bytes)
    Если MinIO упал → кидаешь RuntimeException.
    Если в beforeCompletion упало:
    	•	TM помечает транзакцию как rollback → DB не коммитится.
    После завершения (afterCompletion)
    	5.	afterCompletion(status):
    	•	если COMMITTED:
    	•	лог success
    	•	если ROLLED_BACK:
    	•	removeObjectQuietly(finalKey) (на всякий случай)
    	•	лог failure
    Гарантии
    ✅ Если MinIO недоступен прямо сейчас → DB commit не произойдёт (это сильное свойство).
    ✅ Если RuntimeException в бизнес-логике до commit → DB rollback, MinIO не тронут (если ты пишешь в MinIO только в beforeCompletion).
    ❌ Но нет “prepare” на стороне MinIO, поэтому есть edge cases:
    Где может “сломаться” (и почему это всё равно best-effort)
    	•	MinIO успешно принял объект в beforeCompletion(), но:
    	•	процесс приложения умер до реального commit DB (или сеть/краш на очень плохом тайминге)
    	•	после рестарта DB мог не закоммититься
    → в MinIO может остаться “лишний” файл.
    Ты пытаешься это исправить afterCompletion(ROLLBACK) removeObject, но если приложение умерло до afterCompletion — cleanup не выполнится.
    В XA это решается журналом TM и протоколом recovery. В best-effort — обычно добавляют фоновые уборщики (reconciliation job).
    Где применяется
    	•	Очень часто как “учебное 2PC” или “best-effort координация с внешним HTTP ресурсом”.
    	•	В проде чаще уходят в outbox/saga.



Saga
    Как: каждый шаг коммитится локально, а при ошибке выполняются компенсирующие операции (undo).
    Плюсы: работает с любыми ресурсами.
    Минусы: нет мгновенной атомарности; сложнее.




Transactional Outbox / Inbox (самый популярный “прод” подход без XA)
    Как: в транзакции БД сохраняешь и бизнес-данные, и запись “outbox: нужно сделать действие во внешнем мире”. Потом воркер читает outbox и выполняет (MinIO upload), с ретраями/идемпотентностью.
    Плюсы: очень надёжно при падениях, хорошо масштабируется.
    Минусы: это eventual consistency (не моментальная атомарность).




TCC (Try-Confirm-Cancel)
    Как: внешний ресурс должен поддерживать “try/reserve”, потом confirm или cancel.
    Плюсы: мощно.
    Минусы: MinIO так не умеет (нет “reserve object”).






С MinIO невозможно сделать “настоящий XA-2PC”, потому что MinIO не XA-ресурс.
Поэтому у тебя реально 2 адекватных стратегии:

Best-effort 2PC через JTA Synchronization
    Это то, что ты сейчас делал в “новой” схеме:
    	•	Внутри @Transactional сохраняешь vehicles
    	•	В beforeCompletion() сохраняешь файл в MinIO
    	•	если MinIO упал → исключение → rollback БД
    	•	В afterCompletion(ROLLBACK) удаляешь файл (best-effort), логируешь ошибку
    Почему это лучший вариант для защиты:
    	•	прямо демонстрирует “2 фазы”
    	•	удовлетворяет условию: “отказ MinIO — БД не коммитится”
    	•	удовлетворяет условию: “RuntimeException — rollback, файла нет”
    	•	легко показывается в JMeter (параллельные транзакции)
    Что важно довести до “идеала”:
    	•	объект в MinIO писать только в beforeCompletion() (у тебя это уже есть)
    	•	при любом неуспехе fileObjectKey = null
    	•	в логировании (REQUIRES_NEW) аккуратно: если БД умерла, лог не запишется — это надо честно проговаривать
Outbox (eventual consistency)
    outbox был бы надёжнее:
    	•	Сначала коммитишь БД (vehicles + запись outbox)
    	•	Потом воркер грузит файл в MinIO
    	•	Если воркер упал — потом догрузит
    Но это не то, что обычно хотят в этой лабораторной (там прям про транзакционность и 2PC).


========================================================================================================================
ПОЧЕМУ:

С учётом твоего задания и того, что на защите от тебя ждут именно “распределённую транзакцию / 2PC на уровне бизнес-логики”, outbox как “основное решение” делать не стоит.

Почему:
	•	В outbox нет атомарности “vehicles + файл” прямо сейчас. Будет “сначала БД, потом (возможно позже) MinIO”. Это eventual consistency.
	•	А в задании прямо написано: “сохранение файлов должно быть реализовано транзакционно по отношению к вставке объектов в БД” и “2PC рекомендуется на уровне бизнес-логики”.
	•	И ещё: они хотят демонстрации отказов, где должно быть видно, что при падении MinIO БД откатывается. В outbox при падении MinIO БД уже закоммичена — ты будешь объяснять, что “так в проде лучше”, но это может не совпасть с критерием “транзакционно”.

Что лучше сделать тебе

Оставь то, что мы делали: best-effort 2PC через TransactionSynchronizationRegistry.registerInterposedSynchronization:
	•	MinIO пишется только в beforeCompletion()
	•	если MinIO упал → кидаешь exception → rollback БД
	•	при rollback → best-effort removeObjectQuietly
	•	в логе при ошибке fileObjectKey = null

Это максимально соответствует тексту задания и легко демонстрируется в 3 сценариях.
========================================================================================================================

Но: как “красиво” упомянуть outbox на защите

Можно сказать так (это обычно +баллы, если аккуратно):
	•	“Для MinIO нельзя сделать XA, поэтому мы сделали best-effort 2PC через beforeCompletion.
В production-системах часто используют outbox/saga для надёжности и ретраев, но это уже eventual consistency и не соответствует требованию ‘транзакционно прямо при импорте’.”
========================================================================================================================
Если преподаватель внезапно скажет “не обязательно атомарно, главное чтобы не терялось и было надёжно”, тогда outbox — топ. Но по формулировке твоей ЛР — они хотят именно “или всё, или ничего”.
========================================================================================================================
	•	В outbox нет атомарности “vehicles + файл” прямо сейчас. Будет “сначала БД, потом (возможно позже) MinIO”. Это eventual consistency.
	•	А в задании прямо написано: “сохранение файлов должно быть реализовано транзакционно по отношению к вставке объектов в БД” и “2PC рекомендуется на уровне бизнес-логики”.
	•	И ещё: они хотят демонстрации отказов, где должно быть видно, что при падении MinIO БД откатывается. В outbox при падении MinIO БД уже закоммичена — ты будешь объяснять, что “так в проде лучше”, но это может не совпасть с критерием “транзакционно”.





------------------------------------------------------------------------------------------------------------------------

Почему именно эта реализация нужна в этой работе

1) В задании требуется “транзакционно” между БД и файловым хранилищем

Требование формулируется как: если импорт неуспешен — не должно остаться ни записей в БД, ни файла в MinIO, и наоборот.

Чтобы это показать в отказах (MinIO down) — нужно, чтобы ошибка в MinIO приводила к rollback БД.

Моя реализация делает ровно это:
	•	Фаза 1: вставка Vehicle в БД в @Transactional
	•	Фаза 2: запись файла в MinIO в beforeCompletion()
	•	если MinIO падает → бросается исключение → коммит БД не происходит (rollback)

То есть выполняется требование: падение MinIO ⇒ в БД ничего не сохранилось.

⸻

2) MinIO — не XA ресурс, поэтому “настоящий XA-2PC” невозможен

Настоящий 2PC в Jakarta EE (JTA/XA) возможен только если оба участника — XA:
	•	XA БД (через XADataSource)
	•	XA JMS и т.п.

Но MinIO/S3 — это HTTP API, у него нет prepare/commit/rollback и нет XA-драйвера → он не может быть участником XA транзакции.

Значит “правильный” инфраструктурный 2PC через Transaction Manager здесь не применим технически.

⸻

3) Реализация через Synchronization — рекомендуемый компромисс для внешних ресурсов

Так как внешний ресурс не XA, единственный способ сделать “похоже на 2PC” в рамках задания — это:
	•	привязать внешнюю операцию к жизненному циклу JTA транзакции
	•	выполнять внешний “commit” на стадии beforeCompletion()

Это и есть best-effort 2PC на уровне бизнес-логики, что прямо соответствует фразе из задания:

“Рекомендуется решать при помощи собственной реализации двухфазного коммита на уровне бизнес-логики приложения.”

⸻

Почему другие варианты хуже / не подходят

A) Настоящий JTA/XA 2PC

Почему не подходит: MinIO не XA, нельзя подключить как XAResource.
Можно сделать XA между DB и JMS, но не между DB и S3.

⸻

B) LRCO (Last Resource Commit)

Почему не подходит/опасен:
	•	LRCO рассчитан на ситуацию “XA + один не-XA ресурс”, но всё равно остаётся риск рассинхронизации при падении между шагами.
	•	Для HTTP-хранилища (MinIO) это обычно не используется и в контейнере часто вообще не поддерживается как “ресурс”.
	•	На защите будет сложно доказать корректность и объяснить настройку.

⸻

C) “Сначала MinIO, потом БД” (или наоборот) без привязки к транзакции

Почему не подходит: это не транзакционно.
	•	Если сначала сохранить файл, потом БД упала → файл останется лишним.
	•	Если сначала БД, потом MinIO упал → записи останутся без файла.
То есть требования “атомарности” не выполняются.

⸻

D) Outbox (в проде круто, но не для этого задания)

Почему не подходит под формулировку “транзакционно”:
	•	Outbox даёт eventual consistency: БД коммитится, а файл может появиться позже (или не появиться, пока воркер не догрузит).
	•	При падении MinIO в момент импорта БД не откатится — будет просто “ждём ретрая”.
	•	Но в задании прямо требуется демонстрация: MinIO down ⇒ БД откатывается. Outbox этому противоречит.

⸻

E) Saga/компенсации

Почему не подходит как основной подход:
	•	Это тоже не мгновенная атомарность: шаги коммитятся отдельно, а “откат” — отдельная операция (удалить файл).
	•	Для защиты сложнее: нужно показывать компенсации, ретраи, reconciliation.
	•	Задание просит именно 2PC “похожее на транзакцию”.